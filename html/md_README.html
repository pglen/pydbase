<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PyDBase: pydbase</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PyDBase
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">pydbase </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md1"></a>
High speed database with key / data</h1>
<h2><a class="anchor" id="autotoc_md2"></a>
Fast data save / retrieve</h2>
<p>The motivation was to create a no frills way of saving / retrieving data fast. the command line tester can drive most aspects of this API;</p>
<h1><a class="anchor" id="autotoc_md3"></a>
API</h1>
<p>The module 'twincore' uses two data files and a lock file. The file names are generated from the base name of the data file. .pidx for the index, .lock for the lock file. The lock file times out in 0.3 seconds and breaks the lock. (in case of frozen process)</p>
<p>Example db creation: </p><pre class="fragment">core = twincore.TwinCore(deffile)
</pre><p> Setting verbosity and debug level: </p><pre class="fragment">twincore.core_quiet = quiet
twincore.core_verbose = verbose
twincore.core_pgdebug = pgdebug
twincore.core_showdel = sdelx
</pre><p> Some basic ops: </p><pre class="fragment">dbsize = core.getdbsize()

core.save_data(keyx, datax)
rec_arr = core.retrieve(keyx, ncount)
print("rec_arr", rec_arr)
</pre> <h2><a class="anchor" id="autotoc_md4"></a>
Structure of the data:</h2>
<pre class="fragment">32 byte header, starting with FILESIG

4 bytes    4 bytes          4 bytes         Variable
------------------------------------------------------------
RECSIG     Hash_of_key      Len_of_key      DATA_for_key
RECSEP     Hash_of_payload  Len_of_payload  DATA_for_payload

    .
    .
    .

RECSIG     Hash_of_key      Len_of_key      DATA_for_key
RECSEP     Hash_of_payload  Len_of_payload  DATA_for_payload

where:
RECSIG="RECB" (record begin here)
RECSEP="RECS" (record separated here)
RECDEL="RECX" (record deleted)

Deleted records are marked with RECSIG mutated from RECB to RECX

  Vacuum will remove the deleted records; Make sure your database has no
pending ops; or non atomic opts;

    (like: find keys - delete keys in two ops)

  New data is appended to the end, no duplicate filtering is done.
Retrieval is searched from reverse, the latest record with this key
is retrieved first. Most of the times this behavior is what people
want; also the record history is kept this way, also a desirable
behavior.
</pre> <h1><a class="anchor" id="autotoc_md5"></a>
The test executable script:</h1>
<p>The file <a class="el" href="pydbase_8py.html">pydbase.py</a> exercises most of the twincore functionality. It also provides examples of how to drive it.</p>
<p>Here is the help screen of pydebase.py: </p><pre class="fragment">    Usage: pydebase.py [options]
      Options: -h         help (this screen)
               -V         print version        ||  -q      quiet on
               -d         debug level (0-10)   ||  -v      verbosity on
               -r         write random data    ||  -w      write record(s)
               -z         dump backwards(s)    ||  -i      show deleted record(s)
               -f  file   input or output file (default: 'first.pydb')
               -n  num    number of records to write
               -g  num    get number of records
               -p  num    skip number of records on get
               -l  lim    limit number of records on get
               -x  max    limit max number of records to get
               -k  key    key to save (quotes for multi words)
               -a  str    data to save (quotes for multi words)
               -y  key    find by key
               -t  key    retrieve by key
               -o  offs   get data from offset
               -e  offs   delete at offset
               -u  rec    delete at position
               -U         Vacuum DB
               -R         recover DB
    The default action is to dump records to screen in reverse order.
</pre> <h2><a class="anchor" id="autotoc_md6"></a>
Comparison to other databases:</h2>
<p>This comparison is to show the time it takes to write 500 records. In the tests the record size is about the same (Hello /vs/ "111 222") Please see the sqlite_test.sql for details of data output;</p>
<p>The test can be repeated with running the 'time.sh' script file. Please note the the time.sh clears all files tests/* for a fair test. </p><pre class="fragment">    sqlite time test, 500 records ...
    real    0m1.537s
    user    0m0.025s
    sys 0m0.050s
    pydbase time test, 500 records ...
    real    0m0.149s
    user    0m0.143s
    sys 0m0.004s
</pre><p> Please mind the fact that the sqlite engine has to do a lot of parsing which we skip doing; That is why pydbase is an order of magnitude faster ...</p>
<h2><a class="anchor" id="autotoc_md7"></a>
Saving more complex data</h2>
<p>The database saves a key / value pair. However, the key can be mutated to contain meta data. (for example adding a string in front of it.) [like: CUST_ for customer details] Also the key can be made unique by adding a UUID to it.</p>
<p>The data can consist of any text / binary. The library <a class="el" href="pypacker_8py.html">pypacker.py</a> can pack any data into a string; A copy of pypacker is included here.</p>
<h1><a class="anchor" id="autotoc_md8"></a>
pypacker.py</h1>
<p>This module can pack arbitrary python data into a string; which can be used to store anything in the pydbase data section.</p>
<p>Example from running <a class="el" href="testpacker_8py.html">testpacker.py</a>: </p><pre class="fragment">org: (1, 2, 'aa', ['bb', b'dd'])
packed: pg s4 'iisa' i4 1 i4 2 s2 'aa' a29 'pg s2 'sb' s2 'bb' b4 'ZGQ=' '
unpacked: [1, 2, 'aa', ['bb', b'dd']]
rec_arr: pg s4 'iisa' i4 1 i4 2 s2 'aa' a29 'pg s2 'sb' s2 'bb' b4 'ZGQ=' '
rec_arr_upacked: [1, 2, 'aa', ['bb', b'dd']]
</pre><p> There is also the option of using pypacker on the key itself. Because the key is identified by its hash, there is no speed penalty; Note that the hash is a 32 bit one; collisions are possible, however unlikely; To compensate, make sure you compare the key proper with the returned key.</p>
<h2><a class="anchor" id="autotoc_md9"></a>
TODO</h2>
<pre class="fragment">Speed up by implementing this as a 'C' module
</pre> <h1><a class="anchor" id="autotoc_md10"></a>
EOF</h1>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
